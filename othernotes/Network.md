# 纵览型问题
## 层次协议模型
- OSI七层协议体系结构
  应用层 表示层 会话层 传输层 网络层 链路层 物理层
- 五层协议体系结构
  应用层 传输层 网络层 链路层 物理层

# 应用层
## DNS解析   
**整体具体流程：** 
  - 先看浏览器是否有域名解析的缓存
  - 再看本机host有无该域名的解析
  - 再看本地DNS服务器有无该域名
  - 本地DNS启用转发模式（递归）或者不启用转发模式（迭代）获得DNS。  
**关于转发模式和不转发**   
- 转发是递归，本地DNS服务器找根域名服务器，由根域名服务器联系顶级域名服务器，顶级联系权限域名服务器，再一次次返回结果。
- 不转发是迭代 本地DNS服务器找根，根返回顶级，本地找顶级，顶级返回权限，本地找权限，权限返回结果。
**使用UDP**  
- 响应时间问题，可以不建立连接，只计算传输解析的时间。无论是递归还是迭代，都需要频繁建立和拆除连接，代价太大。
- 负载问题，大量查询任务导致如果每次查询都建立连接，服务器负载过大。
  
## Http协议

### http 协议的报文格式？http请求行有什么？状态码有哪些？有哪些    
- 请求报文
  - 请求行 请求方法 URL Http版本
  - 请求头 Accept Referer Accept-Language Accept-Encoding User-Agent Host Connection Cookie
  - 报文体

- 应答报文 
  - 响应行 版本 状态码
  - 响应头  
  - 报文体  
**请求方法**
Get和Post的区别？


**请求头字段**
Accept:表示接受资源类型 
Referer:从哪里跳转来的
Accept-Language:接受语言
Accept-Encoding:接受的编码
User-Agent :代理如chrome
Host:主机 可以IP或者域名
Connection:KeepAlive
Cookie:用户信息  
***KeepAlive***
在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive，而HTTP/1.1默认是支持长连接的，有没有这个请求头都行。 Http1.0不支持长连接,即使发送的报头有keepalive 字段.
***Cookie & Session***

**状态码详解**
1xx：返回成功  
2xx：返回成功 200客户端请求成功  
3xx: 重定向 301临时重定向 302永久重定向  
4xx：客户端错误，请求有语法错误或者请求无法实现 401BadRequest语法错误 402未授权 403收到请求但是拒绝服务 404找不到资源  
5xx：服务器端错误-服务器不能实现合法请求 500 服务器发生不可预知错误 503服务器暂时无法处理请求一会可能恢复  

### http 缓存机制都有哪些？什么是 cdn？header 中涉及到缓存的字段有哪些？头部阻塞如何解决？http2新增了哪些功能？

## HTTPS
### Https 原理？对称加密的密钥除了随机数还有什么生成方法？安全性怎么保证？ca证书怎么校验?


# 传输层
## TCP
## UDP
# 网络层
## ICMP
# 链路层
## ARP